<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>新年快乐 - 烟花特效</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }
        html, body {
            overflow: hidden;
            height: 100%;
            width: 100%;
            touch-action: manipulation;
            position: fixed; /* 固定视口，避免滚动影响 */
        }
        body {
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            -webkit-user-select: none;
            user-select: none;
        }
        body::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(2px 2px at 20px 30px, #ffffff, rgba(0,0,0,0)),
                radial-gradient(2px 2px at 40px 70px, #ff99ff, rgba(0,0,0,0)),
                radial-gradient(2px 2px at 50px 160px, #8888ff, rgba(0,0,0,0)),
                radial-gradient(2px 2px at 90px 40px, #ffff00, rgba(0,0,0,0)),
                radial-gradient(2px 2px at 130px 80px, #00ffff, rgba(0,0,0,0)),
                radial-gradient(2px 2px at 160px 120px, #ff00ff, rgba(0,0,0,0));
            background-repeat: repeat;
            background-size: 200px 200px;
            z-index: -1;
            opacity: 0.8;
            animation: twinkle 8s linear infinite;
            transform: translateZ(0); /* 启用GPU加速 */
        }
        @keyframes twinkle {
            0%, 100% { opacity: 0.8; }
            50% { opacity: 0.4; }
        }
        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
            object-fit: cover; /* 覆盖视口，避免留白 */
            image-rendering: -webkit-optimize-contrast; /* 优化渲染质量 */
            image-rendering: pixelated; /* 避免模糊插值 */
        }
        .text-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-family: "Ma Shan Zheng", "华文行楷", "STKaiti", "KaiTi", Arial, sans-serif;
            font-size: clamp(24px, 8vw, 60px);
            font-weight: bold;
            color: white;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.8);
            pointer-events: none;
            text-align: center;
            padding: 0 20px;
            -webkit-font-smoothing: antialiased; /* 文字抗锯齿 */
            backface-visibility: hidden; /* 避免文字模糊 */
        }
        .init-hint {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 255, 255, 0.7);
            font-family: "Ma Shan Zheng", "华文行楷", "STKaiti", "KaiTi", Arial, sans-serif;
            font-size: clamp(14px, 3vw, 18px);
            cursor: pointer;
            text-align: center;
            padding: 10px 20px;
            -webkit-font-smoothing: antialiased;
        }
        @media screen and (orientation: landscape) and (max-height: 500px) {
            .text-overlay {
                font-size: clamp(20px, 7vh, 40px);
            }
            .init-hint {
                bottom: 10px;
                font-size: clamp(12px, 2vh, 16px);
            }
        }
        @media screen and (max-width: 375px) and (max-height: 667px) {
            body::before {
                background-size: 150px 150px;
            }
        }
        @media screen and (min-width: 768px) and (min-height: 1024px) {
            body::before {
                background-size: 250px 250px;
            }
        }
    </style>
</head>
<body>
    <canvas id="fireworkCanvas"></canvas>
    <div class="text-overlay">新年快乐,大吉大利</div>
    <div class="init-hint" id="initHint">点击屏幕开始播放</div>

    <script>
        const canvas = document.getElementById('fireworkCanvas');
        const ctx = canvas.getContext('2d');
        const initHint = document.getElementById('initHint');
        
        // 关键优化：高清Canvas渲染核心函数
        function resizeCanvas() {
            const dpr = window.devicePixelRatio || 1;
            const rect = document.body.getBoundingClientRect(); // 基于body获取准确尺寸
            
            // 强制Canvas像素尺寸 = 显示尺寸 * DPR（彻底解决模糊）
            canvas.width = Math.floor(rect.width * dpr);
            canvas.height = Math.floor(rect.height * dpr);
            
            // 重置上下文状态，避免缩放累积
            ctx.resetTransform();
            ctx.scale(dpr, dpr); // 缩放上下文，绘制逻辑不变但像素更密集
            
            // 固定样式尺寸，确保覆盖视口
            canvas.style.width = `${rect.width}px`;
            canvas.style.height = `${rect.height}px`;
            
            // 优化Canvas渲染质量
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high'; // 高清平滑质量
        }

        // 初始调整+强化事件监听
        resizeCanvas();
        
        // 防抖优化，减少重绘次数
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(resizeCanvas, 50); // 缩短延迟，响应更快
        });
        
        window.addEventListener('orientationchange', () => {
            // 旋转后强制刷新，避免尺寸残留
            setTimeout(() => {
                resizeCanvas();
            }, 100);
        });

        // 页面加载完成后再调整一次，确保尺寸准确
        window.addEventListener('load', resizeCanvas);

        const COLORS = [
            [255, 0, 0],
            [255, 165, 0],
            [255, 255, 0],
            [0, 255, 0],
            [0, 0, 255],
            [128, 0, 128],
            [255, 192, 203]
        ];

        let audioContext;
        let isAudioInited = false;
        let launchBuffers = [];
        let explodeBuffers = [];

        function initAudio() {
            if (!isAudioInited) {
                try {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    isAudioInited = true;
                    initHint.style.display = 'none';
                    generateRealisticSounds();
                } catch (e) {
                    console.error('音频初始化失败:', e);
                    initHint.textContent = '您的浏览器不支持音频播放';
                }
            }
        }

        function generateRealisticSounds() {
            for (let i = 0; i < 3; i++) {
                const bufferSize = audioContext.sampleRate * 1.5;
                const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
                const data = buffer.getChannelData(0);
                for (let j = 0; j < bufferSize; j++) {
                    const time = j / audioContext.sampleRate;
                    const noise = (Math.random() * 2 - 1) * 0.1;
                    const tone = Math.sin(time * 400 * Math.exp(-time * 2)) * 0.2;
                    const volume = Math.exp(-time * 3);
                    data[j] = (noise + tone) * volume;
                }
                launchBuffers.push(buffer);
            }

            for (let i = 0; i < 5; i++) {
                const bufferSize = audioContext.sampleRate * 0.8;
                const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
                const data = buffer.getChannelData(0);
                for (let j = 0; j < bufferSize; j++) {
                    const time = j / audioContext.sampleRate;
                    const crackle = (Math.random() * 2 - 1) * Math.exp(-time * 10);
                    const boom = Math.sin(time * 100) * Math.exp(-time * 5) * 0.3;
                    const spark = Math.sin(time * 2000) * Math.exp(-time * 20) * 0.1;
                    data[j] = (crackle + boom + spark) * 0.5;
                }
                explodeBuffers.push(buffer);
            }
        }

        function playLaunchSound() {
            if (!isAudioInited || launchBuffers.length === 0) return;
            try {
                const source = audioContext.createBufferSource();
                const gainNode = audioContext.createGain();
                source.buffer = launchBuffers[Math.floor(Math.random() * launchBuffers.length)];
                gainNode.gain.setValueAtTime(0.1 + Math.random() * 0.1, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 1.5);
                source.connect(gainNode);
                gainNode.connect(audioContext.destination);
                source.start();
            } catch (e) {
                console.error('发射音效播放失败:', e);
            }
        }

        function playExplodeSound() {
            if (!isAudioInited || explodeBuffers.length === 0) return;
            try {
                const source = audioContext.createBufferSource();
                const gainNode = audioContext.createGain();
                source.buffer = explodeBuffers[Math.floor(Math.random() * explodeBuffers.length)];
                const volume = 0.2 + Math.random() * 0.2;
                gainNode.gain.setValueAtTime(volume, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.8);
                source.connect(gainNode);
                gainNode.connect(audioContext.destination);
                source.start();
            } catch (e) {
                console.error('爆炸音效播放失败:', e);
            }
        }

        // 优化粒子绘制，提升清晰度
        class FireworkParticle {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.speed = Math.floor(Math.random() * 4) + 2;
                this.angle = Math.random() * Math.PI * 2;
                this.gravity = 0.05;
                this.vx = Math.cos(this.angle) * this.speed;
                this.vy = Math.sin(this.angle) * this.speed;
                this.color = color;
                this.life = 100;
                this.decay = Math.random() * 0.08 + 0.9;
                this.alpha = 1; // 新增透明度控制，避免模糊过渡
            }

            update() {
                this.vy += this.gravity;
                this.x += this.vx;
                this.y += this.vy;
                this.vx *= 0.98;
                this.vy *= 0.98;
                this.life *= this.decay;
                this.alpha = this.life / 100; // 透明度与生命值同步
            }

            draw() {
                const size = Math.max(1.5, Math.floor(this.life / 8)); // 增大粒子尺寸，更清晰
                ctx.beginPath();
                ctx.arc(Math.round(this.x), Math.round(this.y), size, 0, Math.PI * 2); // 坐标取整，避免模糊
                ctx.fillStyle = `rgba(${this.color[0]}, ${this.color[1]}, ${this.color[2]}, ${this.alpha})`;
                ctx.fill();
                ctx.closePath(); // 闭合路径，提升渲染效率
            }
        }

        class Firework {
            constructor() {
                const screenWidth = canvas.width / window.devicePixelRatio;
                const screenHeight = canvas.height / window.devicePixelRatio;
                this.x = Math.floor(Math.random() * (screenWidth - 100)) + 50; // 扩大生成范围，避免边缘
                this.y = screenHeight;
                this.targetY = Math.floor(Math.random() * (screenHeight * 0.3)) + 80; // 提高目标位置，更显眼
                this.speed = Math.floor(Math.random() * 3) + 7;
                this.color = COLORS[Math.floor(Math.random() * COLORS.length)];
                this.exploded = false;
                this.particles = [];
                this.hasPlayedLaunchSound = false;
                this.hasPlayedExplodeSound = false;
            }

            update() {
                if (!this.exploded) {
                    this.y -= this.speed;
                    if (!this.hasPlayedLaunchSound) {
                        playLaunchSound();
                        this.hasPlayedLaunchSound = true;
                    }
                    if (this.y <= this.targetY) {
                        this.explode();
                    }
                } else {
                    for (let i = this.particles.length - 1; i >= 0; i--) {
                        const particle = this.particles[i];
                        particle.update();
                        if (particle.life < 1) {
                            this.particles.splice(i, 1);
                        }
                    }
                }
            }

            explode() {
                this.exploded = true;
                if (!this.hasPlayedExplodeSound) {
                    playExplodeSound();
                    this.hasPlayedExplodeSound = true;
                }
                const numParticles = Math.floor(Math.random() * 180) + 180; // 增加粒子数量，更饱满清晰
                for (let i = 0; i < numParticles; i++) {
                    this.particles.push(new FireworkParticle(this.x, this.y, this.color));
                }
            }

            draw() {
                if (!this.exploded) {
                    ctx.beginPath();
                    ctx.arc(Math.round(this.x), Math.round(this.y), 4, 0, Math.PI * 2); // 增大发射点尺寸
                    ctx.fillStyle = `rgb(${this.color[0]}, ${this.color[1]}, ${this.color[2]})`;
                    ctx.fill();
                    ctx.closePath();
                } else {
                    this.particles.forEach(particle => particle.draw());
                }
            }
        }

        let fireworks = [];
        let animationId;
        let fireworkSpawnRate = 0.012; // 提高生成频率，效果更密集

        function init() {
            document.addEventListener('click', initAudio, { once: true });
            document.addEventListener('touchstart', (e) => {
                e.preventDefault();
                initAudio();
            }, { once: true });
            animate();
        }

        function animate() {
            // 降低背景透明度，减少拖影模糊
            ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
            ctx.fillRect(0, 0, canvas.width / (window.devicePixelRatio || 1), canvas.height / (window.devicePixelRatio || 1));

            if (Math.random() < fireworkSpawnRate && isAudioInited) {
                fireworks.push(new Firework());
            }

            for (let i = fireworks.length - 1; i >= 0; i--) {
                const firework = fireworks[i];
                firework.update();
                firework.draw();
                if (firework.exploded && firework.particles.length === 0) {
                    fireworks.splice(i, 1);
                }
            }

            animationId = requestAnimationFrame(animate);
        }

        window.addEventListener('beforeunload', () => {
            cancelAnimationFrame(animationId);
        });

        init();
    </script>
</body>
</html>
